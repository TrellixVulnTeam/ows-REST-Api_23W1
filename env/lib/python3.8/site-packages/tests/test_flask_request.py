"""Test for the flask plugin."""

from collections import namedtuple
import json
import os
from unittest.mock import MagicMock
from unittest.mock import patch
import uuid

from _pytest.monkeypatch import MonkeyPatch
import flask
from flask import g
from owsresponse import response
from owsresponse import status
import pytest

from owsrequest import access
from owsrequest import auth
from owsrequest import config
from owsrequest import flask_request
from owsrequest import request
from owsrequest import rules
from owsrequest.constants import errors
from owsrequest.constants import headers
from tests.fixtures import flask_global


monkeypatch = MonkeyPatch()
Context = namedtuple(
    'Context',
    'identity_id orchard_user_id context_type ' +
    'profile_id profile_type identity_uuid'
)


def setup_function(function):
    """Invoked for every test function.

    Args:
        function (callable): the function that will run the test.
    """
    flask_global.mock(monkeypatch)


def teardown_function(function):
    """Invoked everytime a test function has completed.

    Args:
        function (callable): the function that has run.
    """
    monkeypatch.undo()


def test_get_ows():
    """Test getting ows."""
    ows = flask_request.get_ows()
    assert isinstance(ows, flask_request.Ows)
    assert isinstance(g.ows, flask_request.Ows)
    assert g.ows is ows


def test_setup(monkeypatch):
    """Test setting up a flask request on the application."""
    application_name = 'ows-product'
    environment = 'prod'
    service_name = 'service-name'
    path = '/path'
    application = flask.Flask(application_name)

    monkeypatch.setattr(
        flask_request, 'process', MagicMock(spec=flask_request.process))
    monkeypatch.setattr(
        auth, 'initialize_cache', MagicMock(return_value=None))

    flask_request.setup(application, environment, uwsgi_cache_enabled=True)
    for method in flask_request.METHODS:
        assert hasattr(request, method.lower())

    for method in flask_request.METHODS:
        attribute = method.lower()
        getattr(request, attribute)(service_name, path, headers={'foo': 'bar'})

        arguments = flask_request.process.call_args[0]
        options = flask_request.process.call_args[1]
        assert arguments == (
            application_name, environment, method.upper(), service_name, path)
        assert options == {'headers': {'foo': 'bar'},
                           'uwsgi_cache_enabled': True}


@pytest.mark.parametrize('authorization_token, validation_method, module', [
    ('xxx', 'confirm_authorization', request),
    ('Bearer xxx', 'validate_jwt_token', auth),
])
def test_authorize_request(
        monkeypatch, authorization_token, validation_method, module):
    """Testing an authorized request."""
    monkeypatch.setattr(
        module, validation_method,
        MagicMock(
            return_value=response.Response(),
            spec=request.confirm_authorization
            if validation_method == 'confirm_authorization'
            else auth.validate_jwt_token))

    current_request = MagicMock()
    current_request.headers = {
        'Authorization': authorization_token,
        'Correlation-Id': 'cid'
    }

    monkeypatch.setattr(flask_request, 'current_request', current_request)
    jwks = {'keys': [{'test'}]}
    auth_response = flask_request.authorize_request('prod', jwks)
    assert not isinstance(auth_response, flask.Response)
    assert not g.log.error.called


@pytest.mark.parametrize(
    'unauthorized_message, authorization_token, validation_method, module', [
        (errors.AUTH_EXPIRED, 'xxx', 'confirm_authorization', request),
        (errors.AUTH_NOT_FOUND, 'xxx', 'confirm_authorization', request),
        (errors.HMAC_MISMATCH, 'xxx', 'confirm_authorization', request),
        (errors.SENDER_MISMATCH, 'xxx', 'confirm_authorization', request),
        (errors.AUTH_EXPIRED, 'Bearer xxx', 'validate_jwt_token', auth),
        (errors.INVALID_CLAIM, 'Bearer xxx', 'validate_jwt_token', auth),
        (errors.INVALID_TOKEN, 'Bearer xxx', 'validate_jwt_token', auth)
    ])
def test_authorize_invalid_request(
        monkeypatch, unauthorized_message,
        authorization_token, validation_method, module):
    """Testing an authorizing an invalid request both for prod and qa."""
    monkeypatch.setattr(
        module, validation_method,
        MagicMock(
            return_value=response.create_error_response(
                code=errors.UNAUTHORIZED_CODE,
                message=errors.UNAUTHORIZED_MESSAGE.get(
                    unauthorized_message)
                if validation_method == 'confirm_authorization'
                else errors.UNAUTHORIZED_JWT_MESSAGE.get(
                    unauthorized_message),
                status=status.UNAUTHORIZED
            ),
            spec=request.confirm_authorization
            if validation_method == 'confirm_authorization'
            else auth.validate_jwt_token))

    environment = 'prod'
    correlation_id = 'cid'
    authorization = authorization_token
    orchard_user_id = 'alw:123'

    current_request = MagicMock()
    current_request.headers = {
        'Authorization': authorization,
        'Correlation-Id': correlation_id,
        'Orchard-User-Id': orchard_user_id
    }

    monkeypatch.setattr(flask_request, 'current_request', current_request)
    jwks = {'keys': [{'test'}]}
    auth_response = flask_request.authorize_request(environment, jwks)
    expected = {
        'code': errors.UNAUTHORIZED_CODE,
        'message': errors.UNAUTHORIZED_MESSAGE.get(unauthorized_message)
        if validation_method == 'confirm_authorization' else
        errors.UNAUTHORIZED_JWT_MESSAGE.get(unauthorized_message)
    }

    assert isinstance(auth_response, flask.Response)
    assert auth_response.status_code == status.UNAUTHORIZED
    assert json.loads(auth_response.data.decode('utf8')) == expected
    g.ows.log.error.assert_called_with(
        errors.UNAUTHORIZED_LOGGLY_MESSAGE.format(
            authorization_response=authorization,
            environment=environment,
            user_id=orchard_user_id,
            correlation_id=correlation_id,
            error_status=status.UNAUTHORIZED,
            error_code=errors.UNAUTHORIZED_CODE,
            error_message=errors.UNAUTHORIZED_MESSAGE.get(
                unauthorized_message)
            if validation_method == 'confirm_authorization' else
            errors.UNAUTHORIZED_JWT_MESSAGE.get(unauthorized_message)
        ))
    auth_response = flask_request.authorize_request('qa', jwks)
    assert isinstance(auth_response, flask.Response)
    assert auth_response.status_code == status.UNAUTHORIZED
    assert json.loads(auth_response.data.decode('utf8')) == expected
    g.ows.log.error.assert_called_with(
        errors.UNAUTHORIZED_LOGGLY_MESSAGE.format(
            authorization_response=authorization,
            environment='qa',
            user_id=orchard_user_id,
            correlation_id=correlation_id,
            error_status=status.UNAUTHORIZED,
            error_code=errors.UNAUTHORIZED_CODE,
            error_message=errors.UNAUTHORIZED_MESSAGE.get(
                unauthorized_message)
            if validation_method == 'confirm_authorization' else
            errors.UNAUTHORIZED_JWT_MESSAGE.get(unauthorized_message)
        ))


@pytest.mark.parametrize(
    'authorization_header_passed, url, is_logged',
    [(True, 'test/other-route', True), (False, 'test/other-route', True),
     (False, 'test/health', False), (False, 'test/hello', False),
     (True, 'test/health', False), (True, 'test/hello', False)])
def test_authorize_request_with_missing_authorization(
        monkeypatch, authorization_header_passed, url, is_logged):
    """Testing an authorized request with missing or blank authorization."""
    monkeypatch.setattr(
        request, 'confirm_authorization',
        MagicMock(
            return_value=response.Response(),
            spec=request.confirm_authorization))

    current_request = MagicMock()
    orchard_user_id = 123
    correlation_id = 'cid'
    environment = 'prod'
    header_dict = {
        'Correlation-Id': correlation_id,
        'Orchard-User-Id': orchard_user_id
    }
    if authorization_header_passed:
        header_dict['Authorization'] = ''
    current_request.headers = header_dict
    current_request.url = url

    monkeypatch.setattr(flask_request, 'current_request', current_request)
    jwks = {'keys': [{'test'}]}
    flask_request.authorize_request(environment, jwks)
    assert not request.confirm_authorization.called
    assert not g.log.error.called
    if is_logged:
        g.ows.log.info.assert_called_with(
            errors.NO_AUTHORIZATION_MESSAGE.format(
                request_method=current_request.method,
                request_body=current_request.get_data(),
                request_url=current_request.url,
                environment=environment,
                user_id=orchard_user_id,
                correlation_id=correlation_id))


@pytest.mark.no_owsrequest_patch
def test_processing(monkeypatch):
    """Ensuring that the process methods proxies the request."""
    environment = 'prod'
    service_name = 'service-name'
    path = '/path'
    method = 'GET'
    application_name = 'app_name'
    correlation_id = str(uuid.uuid1())
    headers = {'foo': 'bar'}

    value = {}
    monkeypatch.setattr(request, 'process', MagicMock(
        spec=request.process, return_value=value))

    response = flask_request.process(
        application_name, environment, method, service_name, path,
        headers=headers, correlation_id=correlation_id,
        uwsgi_cache_enabled=True)

    assert response is value
    assert request.process.call_args[0][0] == application_name
    assert request.process.call_args[0][1] == environment
    assert request.process.call_args[0][2] == method
    assert request.process.call_args[0][3] == service_name
    assert request.process.call_args[0][4] == path
    assert request.process.call_args[0][5] == correlation_id
    assert request.process.call_args[1].get('uwsgi_cache_enabled') is True
    assert request.process.call_args[1].get('headers') == headers


@pytest.mark.parametrize('correlation_id', (None, uuid.uuid1()))
def test_next_correlation_id(correlation_id):
    """Test getting the next correlation id."""
    for call_count in range(1, 5):
        response = flask_request.next_correlation_id(correlation_id)
        response_parts = response.split('.')

        if correlation_id:
            assert response_parts[0] == str(correlation_id)
            continue

        assert len(response_parts) == 2
        assert response_parts[1] == str(call_count)


def test_next_correlation_id_on_missing_counter():
    """Missing counter should set it to 0."""
    delattr(g, 'request_counter')
    flask_request.next_correlation_id()
    assert g.ows.request_counter == 1


def test_next_correlation_id_when_missing():
    """Test the unlikely scenario where the correlation id has not been set."""
    delattr(g, 'correlation_id')
    with pytest.raises(AssertionError):
        flask_request.next_correlation_id()


def test_get_grass_headers(monkeypatch):
    """Test relevant Grass headers are returned as a tuple."""
    expected_type = 'account-type'
    expected_id = 'account-id'

    mock_request = MagicMock()
    mock_request.headers.get.side_effect = [expected_type, expected_id]
    result = flask_request.get_grass_headers(mock_request)
    assert result == (expected_type, expected_id)


@pytest.mark.parametrize('required', [True, False])
def test_verify_grass_headers(required, mocker):
    """Test that the generic validation is called with values from headers."""
    expected_type = 'account-type'
    expected_id = 'account-id'

    mock_request = MagicMock()
    mock_request.headers.get.side_effect = [expected_type, expected_id]
    access_response = response.Response(message='lgtm')

    verify_grass_headers = mocker.patch.object(
        access, 'verify_grass_headers', autospec=True,
        return_value=access_response)

    result = flask_request.verify_grass_headers(
        mock_request, required=required)

    verify_grass_headers.assert_called_with(
        expected_type, expected_id, required=required)
    assert result == access_response


def test_verify_grass_headers_default_required(mocker):
    """Test that headers are not required by default."""
    expected_type = 'account-type'
    expected_id = 'account-id'

    mock_request = MagicMock()
    mock_request.headers.get.side_effect = [expected_type, expected_id]

    verify_grass_headers = mocker.patch.object(
        access, 'verify_grass_headers', autospec=True)

    flask_request.verify_grass_headers(mock_request)

    verify_grass_headers.assert_called_with(
        expected_type, expected_id, required=False)


def test_grass_access_verification(mocker):
    """Test Grass Access."""
    expected_type = 'account-type'
    expected_id = 'account-id'
    expected_account_id = 'request-account-id'
    expected_subaccount_id = 'request-subaccount-id'

    mock_request = MagicMock()
    mock_request.headers.get.side_effect = [expected_type, expected_id]

    verify_grass_access = mocker.patch.object(
        access, 'verify_grass_access', autospec=True)

    flask_request.verify_grass_access(
        mock_request, required=True, account=expected_account_id,
        subaccount=expected_subaccount_id)

    verify_grass_access.assert_called_with(
        expected_type, expected_id, required=True, account=expected_account_id,
        subaccount=expected_subaccount_id)


@pytest.mark.parametrize('header_data', [
    [headers.GRASS_ACCOUNT_TYPE_VENDOR, '10982'],
    [headers.GRASS_ACCOUNT_TYPE_VENDOR, ''],
    [headers.GRASS_ACCOUNT_TYPE_VENDOR, None],
    [headers.GRASS_ACCOUNT_TYPE_SUBACCOUNT, '10982'],
    [headers.GRASS_ACCOUNT_TYPE_SUBACCOUNT, ''],
    [headers.GRASS_ACCOUNT_TYPE_SUBACCOUNT, None],
    ['', '10909282'],
    [None, '10909282']])
def test_verify_grass_ownership(header_data):
    """Test verifying Grass ownership with valid headers."""
    mock_request = MagicMock()
    mock_request.headers.get.side_effect = header_data

    ownership_response = response.Response()
    method = MagicMock(return_value=ownership_response)
    method_arguments = ('some', 'values', 'to', 'provide')
    method_named_parameters = {'additional': 'data'}

    ownership = flask_request.verify_grass_ownership(
        mock_request, method, *method_arguments, **method_named_parameters)

    assert ownership is ownership_response
    method.assert_called_with(
        *method_arguments, account_type=header_data[0],
        account_id=header_data[1], **method_named_parameters)


def test_verify_grass_ownership_without_grass_headers():
    """Test verifying Grass ownership with no grass headers."""
    method = MagicMock()
    method_arguments = ('some', 'values', 'to', 'provide')
    method_named_parameters = {'additional': 'data'}

    mock_request = MagicMock()
    mock_request.headers = {}
    ownership = flask_request.verify_grass_ownership(
        mock_request, method, *method_arguments, **method_named_parameters)
    assert ownership.status == status.OK
    assert not method.called


@pytest.mark.parametrize(('profile_type', 'profile_id'), [
    ('a', '1'),
    ('foo', 'bar'),
    (None, None),
])
@patch('flask.request')
def test_get_profile_headers(mock_request, profile_type, profile_id):
    """Test get_profile_headers."""
    header_data = {
        headers.ORCHARD_PROFILE_TYPE: profile_type,
        headers.ORCHARD_PROFILE_ID: profile_id
    }
    mock_request.headers = header_data
    profile_type, profile_id = flask_request.get_profile_headers(mock_request)

    assert profile_type == header_data[headers.ORCHARD_PROFILE_TYPE]
    assert profile_id == header_data[headers.ORCHARD_PROFILE_ID]


@pytest.mark.parametrize(('profile_type', 'profile_id', 'expected'), [
    ('dummy', 'id', 200),
    ('', '', 200),
    (None, None, 200),
    ('', 'id', 400),
    ('dummy', '', 400),
    (None, 123, 400),
    ('dummy', None, 400),
])
@patch('flask.request')
def test_verify_profile_headers(
        mock_request, profile_type, profile_id, expected):
    """Test verify_profile_headers."""
    header_data = {
        headers.ORCHARD_PROFILE_TYPE: profile_type,
        headers.ORCHARD_PROFILE_ID: profile_id
    }
    mock_request.headers = header_data
    result = flask_request.verify_profile_headers(mock_request)

    assert result.status == expected


@pytest.mark.parametrize((
        'head_profile_type', 'head_profile_id', 'profile_type', 'profile_id',
        'expected'
), [
    # direct calls.
    (None, None, 'dummy', '123', 200),
    ('', '', 'dummy', '123', 200),
    # via grass
    ('dummy', '456', 'dummy', '123', 403),
    ('random', '123', 'dummy', '123', 403),
    ('dummy', 123, 'dummy', '123', 200),
    ('dummy', '123', 'dummy', '123', 200),
    # fake calls
    (None, '123', 'dummy', '123', 400),
    ('dummy', None, 'dummy', '123', 400),
])
@patch('flask.request')
def test_verify_profile_headers_match_route(
        mock_request, head_profile_type, head_profile_id, profile_type,
        profile_id, expected):
    """Test verify_profile_headers_match_route."""
    header_data = {
        headers.ORCHARD_PROFILE_TYPE: head_profile_type,
        headers.ORCHARD_PROFILE_ID: head_profile_id
    }
    mock_request.headers = header_data
    result = flask_request.verify_profile_headers_match_route(
        mock_request, profile_type, profile_id)

    assert result.status == expected


@patch.dict(os.environ, {'Environment': 'prod'})
@patch('flask.request')
@pytest.mark.parametrize(
    ('required', 'header_data', 'log_non_grass_headers_access'),
    [(True, {
        headers.GRASS_ACCOUNT_TYPE: 'vendor',
        headers.GRASS_ACCOUNT_ID: 1234,
        'Correlation-Id': 'c-id'},
      False),
     (True, {}, False),
     (False, {
        headers.GRASS_ACCOUNT_TYPE: 'vendor',
        headers.GRASS_ACCOUNT_ID: 1234,
        'Correlation-Id': 'c-id'},
      False),
     (False, {}, True)])
def test_log_verify_grass_headers(
        mock_request, required, header_data, log_non_grass_headers_access):
    """Test that the request with no Grass headers is logged."""
    mock_request.headers = header_data

    flask_request.verify_grass_headers(
        mock_request, required=required)
    if log_non_grass_headers_access:
        g.ows.log.info.assert_called_with(
            errors.NO_GRASS_HEADERS_MESSAGE.format(
                request_method=mock_request.method,
                request_body=mock_request.get_data(),
                request_url=mock_request.url,
                environment='prod',
                correlation_id=mock_request.headers.get('Correlation-Id', '')))
    else:
        assert not g.log.info.called


@patch.dict(os.environ, {'Environment': 'prod'})
@patch('flask.request')
@pytest.mark.parametrize(
    ('required', 'header_data', 'log_non_grass_headers_access'),
    [(True, {
        headers.GRASS_ACCOUNT_TYPE: 'vendor',
        headers.GRASS_ACCOUNT_ID: 1234,
        'Correlation-Id': 'c-id'},
      False),
     (True, {}, False),
     (False, {
        headers.GRASS_ACCOUNT_TYPE: 'vendor',
        headers.GRASS_ACCOUNT_ID: 1234,
        'Correlation-Id': 'c-id'},
      False),
     (False, {}, True)])
def test_log_verify_grass_access(
        mock_request, required, header_data, log_non_grass_headers_access):
    """Test that the request with no Grass headers is logged."""
    mock_request.headers = header_data

    flask_request.verify_grass_access(
        mock_request, required=required)
    if log_non_grass_headers_access:
        g.ows.log.info.assert_called_with(
            errors.NO_GRASS_HEADERS_MESSAGE.format(
                request_method=mock_request.method,
                request_body=mock_request.get_data(),
                request_url=mock_request.url,
                environment='prod',
                correlation_id=mock_request.headers.get('Correlation-Id', '')))
    else:
        assert not g.log.info.called


def test_ows_get_headers_full_profile(monkeypatch):
    """Test it can fill out full profile headers."""
    context = Context(
        identity_id=1,
        orchard_user_id=1,
        context_type='profile',
        profile_id=2,
        profile_type='Podcast',
        identity_uuid=6,
    )
    monkeypatch.setattr(
        flask_request, '_request_context', MagicMock(return_value=context))
    assert flask_request.get_ows_headers() == {
        'Orchard-Identity-Id': 1,
        'Orchard-Identity-UUID': 6,
        'Orchard-Profile-Id': 2,
        'Orchard-Profile-Type': 'Podcast'
    }


def test_ows_get_headers_partial_profile(monkeypatch):
    """Test it can fill out partial profile headers."""
    context = Context(
        identity_id=None,
        orchard_user_id=1,
        context_type='profile',
        profile_id=2,
        profile_type=None,
        identity_uuid=None,
    )
    monkeypatch.setattr(
        flask_request, '_request_context', MagicMock(return_value=context))
    assert flask_request.get_ows_headers() == {
        'Orchard-Profile-Id': 2,
    }


def test_ows_get_headers_full_account(monkeypatch):
    """Test it can fill out full account headers."""
    context = Context(
        identity_id=1,
        orchard_user_id=1,
        context_type='account',
        profile_id=2,
        profile_type='Cow',
        identity_uuid=None,
    )
    monkeypatch.setattr(
        flask_request, '_request_context', MagicMock(return_value=context))
    assert flask_request.get_ows_headers() == {
        'Grass-Account-Id': 2,
        'Grass-Account-Type': 'Cow',
        'Orchard-User-Id': 1
    }


def test_ows_get_headers_partial_account(monkeypatch):
    """Test it can fill out partial account headers."""
    context = Context(
        identity_id=1,
        orchard_user_id=1,
        context_type='account',
        profile_id=None,
        profile_type=None,
        identity_uuid=None,
    )
    monkeypatch.setattr(
        flask_request, '_request_context', MagicMock(return_value=context))
    assert flask_request.get_ows_headers() == {
        'Orchard-User-Id': 1
    }


@pytest.mark.parametrize(
    'requestor_service_name,log_only,profile_type,access_denied,path',
    [
        ('graphql-product', True, 'LabelProfile', False, '/holds/234'),
        (None, True, 'LabelProfile', False, '/holds/234'),
        ('graphql-product', True, 'IncorrectProfile', True, '/holds/234'),
        ('ows-grass', False, 'IncorrectProfile', True, '/holds/234'),
        ('ows-users', True, 'LabelProfile', False, '/health'),
        ('ows-users', True, 'LabelProfile', False, '/hello'),
    ]
)
def test_verify_rules_access(
        monkeypatch, requestor_service_name, log_only, profile_type,
        access_denied, path):
    """Verify rules access setup."""
    current_request = MagicMock()
    current_request.headers = {
        'Orchard-Requester-Service': requestor_service_name,
        'Correlation-Id': 'cid'
    }
    current_request.method = 'PUT'
    current_request.path = '/holds/234'

    request_context = MagicMock()
    request_context.requestor_service_name = requestor_service_name
    request_context.profile_type = profile_type
    request_context.profile_id = 'abc'
    request_context.roles = ['catalog']
    monkeypatch.setattr(
        flask_request, '_request_context', MagicMock(
            return_value=request_context))

    validator = rules.EndpointRulesValidator('tests/fixtures/rules.yaml')

    monkeypatch.setattr(flask_request, 'current_request', current_request)

    response = flask_request.verify_rules_access(
        current_request, validator, log_only)

    if requestor_service_name not in config.ACCESS_CONTROL_SERVICES:
        g.ows.log.info.assert_called_with(
            errors.SKIP_ROLE_CHECK_MESSAGE.format(requestor_service_name))

    if access_denied:
        g.ows.log.error.assert_called_with(
            errors.ACCESS_DENIED_MESSAGE.format(
                method='PUT',
                path='/holds/234',
                profile_id='abc',
                profile_type=profile_type,
                roles=['catalog'],
                correlation_id='cid'
            ))
        if not log_only:
            assert response.status_code == 403
            assert response.json['code'] == errors.ERROR_CODE_FORBIDDEN


@pytest.mark.parametrize('path,access_denied', [
    ('/users/identity/a0b8f767-707a-432c-989e-b3b3f74d9cb7/devices', True),
    ('/users/identity/e058c7f5-5102-4e80-9400-5d20d972bccd', True),
    ('/users/identity/e058c7f5-5102-4e80-9400-5d20d972bccd/profiles', True),
    ('/identity/c3497c61-e018-4da6-af38-b57624980fa6/applications', True),
    ('/hello/', False),
    ('/users/identity/a0b8f767-707a-432c-989e-b3b3f74d9cb7/application/orchard-go/profiles', False),  # noqa
    ('/users/identity/d907a6b7-c3e2-4d6f-be27-97ab89fde179/application/orchard-go/profiles', False),  # noqa
    ('/users/identity/e058c7f5-5102-4e80-9400-5d20d972bccd/application/frontend-publishing/profiles', False),  # noqa
    ('/users/identity/c3497c61-e018-4da6-af38-b57624980fa6/application/frontend-insights/profiles', False),  # noqa
])
def test_verify_rules_access_exclude_paths(monkeypatch, path, access_denied):
    """Verify rules access exclude_paths."""
    current_request = MagicMock()
    current_request.headers = {
        'Orchard-Requester-Service': 'graphql-product',
        'Correlation-Id': 'cid'
    }
    current_request.method = 'GET'
    current_request.path = path

    request_context = MagicMock()
    request_context.requestor_service_name = 'graphql-product'
    request_context.profile_type = 'LabelProfile'
    request_context.profile_id = 'abc'
    request_context.roles = ['catalog']
    monkeypatch.setattr(
        flask_request, '_request_context', MagicMock(
            return_value=request_context))

    exclude_paths = [
        '/hello/',
        '/users/identity/<str>/application/<str>/profiles'
    ]
    validator = rules.EndpointRulesValidator('tests/fixtures/rules.yaml')
    monkeypatch.setattr(flask_request, 'current_request', current_request)

    verify_response = flask_request.verify_rules_access(
        current_request, validator, False, exclude_paths)

    if access_denied:
        assert verify_response.status_code == 403
        g.ows.log.error.assert_called_with(
            errors.ACCESS_DENIED_MESSAGE.format(
                method=current_request.method,
                path=current_request.path,
                profile_id=request_context.profile_id,
                profile_type=request_context.profile_type,
                roles=request_context.roles,
                correlation_id='cid'
            ))
    else:
        assert verify_response is None
